<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>SPOS Practicals</title>
<style>
  body { background:#0b0b0b; color:#eaeaea; font-family:'Segoe UI',sans-serif; padding:40px; line-height:1.6; }
  h1 { color:#00fff7; text-align:center; margin-bottom:30px; }
  h2 { color:#00d0ff; margin-top:30px; }
  a { color:#00ffa2; text-decoration:none; font-weight:bold; font-size:1.05em; }
  a:hover { text-decoration:underline; color:#fff; }
  p { color:#bfbfbf; margin:6px 0 16px 0; }
  footer { margin-top:50px; text-align:center; font-size:0.85em; color:#777; }
  .file-section { margin-bottom:25px; border-bottom:1px solid #222; padding-bottom:15px; }
  .explanation {
    background:#1b1b1b;
    color:#ccc;
    border-left:4px solid #00fff7;
    padding:10px 20px;
    border-radius:10px;
    margin:10px 0 25px 0;
    font-size:0.95em;
  }
  .explanation pre {
    background:#111;
    color:#00ffa2;
    padding:8px;
    border-radius:8px;
    overflow-x:auto;
  }
  .explanation h3 {
    color:#00ffa2;
    margin-bottom:5px;
  }
</style>
</head>
<body>
  <h1>SPOS Practicals - Quick Access</h1>

  <!-- CPU Scheduling (FCFS, SJF, Priority, RR) -->
  <div class="file-section">
    <h2><a href="FCFS.txt" target="_blank">1ï¸âƒ£ FCFS</a></h2>
    <h2><a href="SJF.txt" target="_blank">2ï¸âƒ£ SJF (Preemptive)</a></h2>
    <h2><a href="PriorityScheduling.txt" target="_blank">3ï¸âƒ£ Priority Scheduling</a></h2>
    <h2><a href="RoundRobin.txt" target="_blank">4ï¸âƒ£ Round Robin</a></h2>

    <p><b>Concept:</b> Decide process execution order using FCFS, SJF, Priority, and Round Robin scheduling.</p>
    <div class="explanation">
      <h3>ğŸ” Explanation:</h3>
      <pre>
What are CPU Scheduling Algorithms?
Methods used by the OS to decide which process gets CPU time and when.

ğŸ” KEY METRICS:
- AT (Arrival Time), BT (Burst Time), CT (Completion Time)
- TAT = CT - AT, WT = TAT - BT

ğŸ“‹ FCFS:
- Non-preemptive; executes in arrival order.
- Simple but causes convoy effect.

âš¡ SJF (Preemptive):
- Shortest Remaining Time First (SRTF).
- Minimizes waiting time but may starve long jobs.

ğŸ¯ Priority Scheduling:
- Executes highest-priority process first.
- Lower number = higher priority.
- Starvation solved by aging.

ğŸ”„ Round Robin:
- Each process gets fixed time quantum (TQ).
- Preemptive and fair for all.

COMPARISON:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Algorithm   â”‚ Preemptive  â”‚ Starvation  â”‚ Best For    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ FCFS        â”‚ No          â”‚ No          â”‚ Batch       â”‚
â”‚ SJF         â”‚ Yes         â”‚ Possible    â”‚ Min WT      â”‚
â”‚ Priority    â”‚ No          â”‚ Possible    â”‚ Real-time   â”‚
â”‚ Round Robin â”‚ Yes         â”‚ No          â”‚ Time-share  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      </pre>
    </div>
  </div>

  <!-- Memory Placement -->
  <div class="file-section">
    <h2><a href="MemoryScheduling.txt" target="_blank">5ï¸âƒ£ Memory Placement Strategies</a></h2>
    <p><b>Concept:</b> Simulate First Fit, Best Fit, Worst Fit, and Next Fit memory allocation.</p>
    <div class="explanation">
      <h3>ğŸ” Explanation:</h3>
      <pre>
What are Memory Allocation Strategies?
Algorithms that allocate memory blocks to processes efficiently.

ğŸ¯ FIRST FIT:
- Scans from start; allocates first block that fits.
- Fast, simple; may fragment start of memory.

ğŸ† BEST FIT:
- Allocates smallest possible block that fits.
- Minimizes internal waste; slower due to full scan.

ğŸ“ˆ WORST FIT:
- Allocates largest block.
- Reduces small fragments; wastes memory.

ğŸ”„ NEXT FIT:
- Starts search from last allocation point.
- Circular search distributes allocation evenly.

KEY CONCEPTS:
- Internal Fragmentation: Wasted inside allocated block.
- External Fragmentation: Free blocks too small for any process.
- Compaction: Shifting memory to reduce fragmentation.
      </pre>
    </div>
  </div>

  <!-- Page Replacement -->
  <div class="file-section">
    <h2><a href="PageReplacement.txt" target="_blank">6ï¸âƒ£ Page Replacement Algorithms</a></h2>
    <p><b>Concept:</b> Replace memory pages efficiently using FIFO, LRU, and Optimal algorithms.</p>
    <div class="explanation">
      <h3>ğŸ” Explanation:</h3>
      <pre>
What are Page Replacement Algorithms?
OS strategies to decide which page to remove when memory is full.

ğŸ” KEY CONCEPTS:
- Page Fault: Requested page not in memory.
- Page Hit: Page already loaded.
- Frame: Memory slot holding a page.

ğŸ“‹ FIFO:
- Replace oldest page.
- Simple but shows Beladyâ€™s anomaly.

ğŸ•’ LRU:
- Replace least recently used page.
- Based on usage history, approximates optimal.

ğŸ¯ OPTIMAL:
- Replace page used farthest in the future.
- Theoretical minimum faults; not practical.

BELADYâ€™S ANOMALY:
- In FIFO, increasing frames can increase faults.
      </pre>
    </div>
  </div>

  <!-- Synchronization -->
  <div class="file-section">
    <h2><a href="ProducerConsumer.txt" target="_blank">7ï¸âƒ£ Producerâ€“Consumer Synchronization</a></h2>
    <p><b>Concept:</b> Demonstrates process synchronization using Mutex and Semaphore.</p>
    <div class="explanation">
      <h3>ğŸ” Explanation:</h3>
      <pre>
What are Synchronization Mechanisms?
Used to coordinate threads accessing shared resources.

ğŸ”’ MUTEX:
- Ensures only one thread enters critical section.
- Uses lock/unlock methods.

ğŸš¦ SEMAPHORE:
- Controls multiple threads via permit count.
- wait(P) to acquire, signal(V) to release.

KEY DIFFERENCES:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Aspect      â”‚ Mutex       â”‚ Semaphore   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Purpose     â”‚ Exclusion   â”‚ Control poolâ”‚
â”‚ Ownership   â”‚ Thread owns â”‚ No ownershipâ”‚
â”‚ Count       â”‚ Binary (1)  â”‚ >1 allowed  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      </pre>
    </div>
  </div>

  <!-- Two Pass Assembler -->
  <div class="file-section">
    <h2><a href="TwoPassAssembler.txt" target="_blank">8ï¸âƒ£ Two Pass Assembler</a></h2>
    <p><b>Concept:</b> Converts assembly code to machine code using symbol & literal tables.</p>
    <div class="explanation">
      <h3>ğŸ” Explanation:</h3>
      <pre>
What is a Two Pass Assembler?
Converts assembly language to machine code in two phases.

PASS 1:
- Builds Symbol Table (labels) and Literal Table (=5, =10)
- Tracks addresses via Location Counter.
- Produces intermediate code.

PASS 2:
- Uses tables to replace symbols with addresses.
- Generates final machine code.

KEY COMPONENTS:
1. Symbol Table
2. Literal Table
3. Opcode Table
4. Location Counter

Handles forward references by resolving addresses before Pass 2.
      </pre>
    </div>
  </div>

  <!-- Macro Processor -->
  <div class="file-section">
    <h2><a href="MacroProcessor.txt" target="_blank">9ï¸âƒ£ Macro Processor</a></h2>
    <p><b>Concept:</b> Expands macros before assembly; replaces macro calls with their definitions.</p>
    <div class="explanation">
      <h3>ğŸ” Explanation:</h3>
      <pre>
What is a Two Pass Macro Processor?
Processes macros in two passes.

PASS 1:
- Detects MACRO...MEND definitions.
- Builds:
  â€¢ MNT (Macro Name Table)
  â€¢ MDT (Macro Definition Table)
  â€¢ ALA (Argument List Array)
- Replaces parameters with #1, #2.

PASS 2:
- Scans for macro calls, substitutes arguments.
- Expands macros into actual code.

Example:
Input:
  MACRO
  ADD_TWO A,B
  LOAD A
  ADD B
  MEND
  ADD_TWO X,Y

Output:
  LOAD X
  ADD Y
      </pre>
    </div>
  </div>

  <!-- DLL / Dynamic Linking Loader -->
  <div class="file-section">
    <h2><a href="DLL.txt" target="_blank">ğŸ”Ÿ Dynamic Linking Loader (DLL)</a></h2>
    <p><b>Concept:</b> Combines multiple object modules into a single executable by resolving external references and performing relocation at load time.</p>
    <div class="explanation">
      <h3>ğŸ” Explanation:</h3>
      <pre>
What is a Dynamic Linking Loader?
A system program that combines multiple object modules into a single executable program
by resolving external references and performing address relocation at load time.

PASS 1 (Symbol Table Construction):
- Scans all object modules to find symbol definitions
- Builds ESTAB (External Symbol Table) mapping symbol names to addresses
- Processes DEF records: symbols defined in current module
- Handles START records: module loading addresses
- Creates global symbol table for reference resolution

PASS 2 (Linking and Relocation):
- Processes REF records: external symbol references
- Resolves references using ESTAB built in Pass 1
- Handles TEXT records: executable instructions with operands
- Performs address relocation by substituting symbol addresses
- Reports unresolved symbols as linking errors

Key Components:
1. ESTAB (External Symbol Table): Maps symbol names to absolute addresses
2. Object Modules: Contains DEF, REF, TEXT, START records
3. Symbol Resolution: Matches references with definitions
4. Address Relocation: Converts symbolic addresses to absolute addresses

Record Types:
- DEF: Symbol definition (symbol name, offset)
- REF: External reference (symbol name)
- TEXT: Executable instruction (opcode, operand)
- START: Module starting address

Example Flow:
Module A defines FUNC at offset 100
Module B references FUNC
Pass 1: ESTAB[FUNC] = base_address + 100
Pass 2: Replace FUNC reference with actual address from ESTAB

Benefits:
- Modular programming support
- Code reusability
- Separate compilation
- Dynamic symbol resolution
- Memory-efficient loading

This approach enables linking multiple independently compiled modules
into a single executable program with proper symbol resolution.
      </pre>
    </div>
  </div>

  <footer>
    SPOS Lab Practical Codes Â© 2025 
  </footer>
</body>
</html>
